package generator

import (
	"bytes"
	"fmt"
	"strings"

	"github.com/yourusername/lv-go/internal/models"
)

// GenerateTOML generates a TOML string from VectorConfiguration
func GenerateTOML(config *models.VectorConfiguration, sourcePath string) (string, error) {
	var buf bytes.Buffer

	// Add header comments
	buf.WriteString("# Generated by lv-go - Logstash to Vector Migration Tool\n")
	buf.WriteString(fmt.Sprintf("# Source: %s\n\n", sourcePath))

	// Generate sources
	for _, source := range config.Sources {
		if err := writeComponent(&buf, "sources", source); err != nil {
			return "", fmt.Errorf("failed to write source: %w", err)
		}
	}

	// Generate transforms
	for _, transform := range config.Transforms {
		if err := writeComponent(&buf, "transforms", transform); err != nil {
			return "", fmt.Errorf("failed to write transform: %w", err)
		}
	}

	// Generate sinks
	for _, sink := range config.Sinks {
		if err := writeComponent(&buf, "sinks", sink); err != nil {
			return "", fmt.Errorf("failed to write sink: %w", err)
		}
	}

	return buf.String(), nil
}

// writeComponent writes a single component to the buffer
func writeComponent(buf *bytes.Buffer, sectionName string, component models.VectorComponent) error {
	// Write comments if present
	if len(component.Comments) > 0 {
		for _, comment := range component.Comments {
			// Handle multi-line comments
			lines := strings.Split(comment, "\n")
			for _, line := range lines {
				buf.WriteString(fmt.Sprintf("# %s\n", line))
			}
		}
	}

	// Write section header
	buf.WriteString(fmt.Sprintf("[%s.%s]\n", sectionName, component.ComponentID))

	// Write type
	buf.WriteString(fmt.Sprintf("type = %s\n", quoteValue(component.ComponentKind)))

	// Write inputs (for transforms and sinks)
	if len(component.Inputs) > 0 {
		inputsStr, err := formatArray(component.Inputs)
		if err != nil {
			return err
		}
		buf.WriteString(fmt.Sprintf("inputs = %s\n", inputsStr))
	}

	// Write config options
	if err := writeConfig(buf, component.Config, ""); err != nil {
		return err
	}

	// Add blank line after component
	buf.WriteString("\n")

	return nil
}

// writeConfig writes configuration options to the buffer
func writeConfig(buf *bytes.Buffer, config map[string]interface{}, prefix string) error {
	for key, value := range config {
		fullKey := key
		if prefix != "" {
			fullKey = prefix + "." + key
		}

		// Handle nested maps (create sub-tables)
		if nestedMap, ok := value.(map[string]interface{}); ok {
			// Check if this is a simple nested structure or needs a table
			if shouldUseInlineTable(nestedMap) {
				// Use inline table for simple structures
				inlineStr, err := formatInlineTable(nestedMap)
				if err != nil {
					return err
				}
				buf.WriteString(fmt.Sprintf("%s = %s\n", fullKey, inlineStr))
			} else {
				// Create a subtable for complex nested structures
				buf.WriteString(fmt.Sprintf("\n[%s]\n", fullKey))
				if err := writeConfig(buf, nestedMap, ""); err != nil {
					return err
				}
			}
			continue
		}

		// Write the value
		valueStr, err := formatValue(value)
		if err != nil {
			return err
		}
		buf.WriteString(fmt.Sprintf("%s = %s\n", fullKey, valueStr))
	}
	return nil
}

// shouldUseInlineTable determines if a nested map should use inline table syntax
func shouldUseInlineTable(m map[string]interface{}) bool {
	// Use inline tables for small, simple structures
	if len(m) > 3 {
		return false
	}
	for _, v := range m {
		// Don't use inline if there are nested structures
		if _, ok := v.(map[string]interface{}); ok {
			return false
		}
		if _, ok := v.([]interface{}); ok {
			return false
		}
	}
	return true
}

// formatInlineTable formats a map as an inline TOML table
func formatInlineTable(m map[string]interface{}) (string, error) {
	parts := []string{}
	for key, value := range m {
		valueStr, err := formatValue(value)
		if err != nil {
			return "", err
		}
		parts = append(parts, fmt.Sprintf("%s = %s", key, valueStr))
	}
	return "{ " + strings.Join(parts, ", ") + " }", nil
}

// formatValue formats a value for TOML output
func formatValue(value interface{}) (string, error) {
	switch v := value.(type) {
	case string:
		// Handle multi-line strings
		if strings.Contains(v, "\n") {
			return formatMultilineString(v), nil
		}
		return quoteValue(v), nil
	case int, int64, int32:
		return fmt.Sprintf("%d", v), nil
	case float32, float64:
		return fmt.Sprintf("%f", v), nil
	case bool:
		return fmt.Sprintf("%t", v), nil
	case []string:
		return formatArray(v)
	case []interface{}:
		return formatInterfaceArray(v)
	case map[string]interface{}:
		return formatInlineTable(v)
	default:
		return fmt.Sprintf("%v", v), nil
	}
}

// formatArray formats a string array for TOML
func formatArray(arr []string) (string, error) {
	quoted := make([]string, len(arr))
	for i, item := range arr {
		quoted[i] = quoteValue(item)
	}
	return "[" + strings.Join(quoted, ", ") + "]", nil
}

// formatInterfaceArray formats an interface array for TOML
func formatInterfaceArray(arr []interface{}) (string, error) {
	quoted := make([]string, len(arr))
	for i, item := range arr {
		valueStr, err := formatValue(item)
		if err != nil {
			return "", err
		}
		quoted[i] = valueStr
	}
	return "[" + strings.Join(quoted, ", ") + "]", nil
}

// formatMultilineString formats a multi-line string with triple quotes
func formatMultilineString(s string) string {
	return "'''\n" + s + "\n'''"
}

// quoteValue quotes a string value for TOML
func quoteValue(s string) string {
	// Escape special characters
	s = strings.ReplaceAll(s, "\\", "\\\\")
	s = strings.ReplaceAll(s, "\"", "\\\"")
	return `"` + s + `"`
}

// GenerateComponentID generates a unique component ID
func GenerateComponentID(pluginName string, componentType models.ComponentType, index int) string {
	return fmt.Sprintf("%s_%s_%d", pluginName, componentType.String(), index)
}
